name: Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: current
        run: echo "version=$(jq -r .version package.json)" >> $GITHUB_OUTPUT

      - name: Calculate new version
        id: new
        run: |
          current="${{ steps.current.outputs.version }}"
          IFS='.' read -r major minor patch <<< "$current"

          case "${{ inputs.version }}" in
            major)
              major=$((major + 1))
              minor=0
              patch=0
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              ;;
            patch)
              patch=$((patch + 1))
              ;;
          esac

          echo "version=$major.$minor.$patch" >> $GITHUB_OUTPUT

      - name: Update package.json
        run: |
          jq '.version = "${{ steps.new.outputs.version }}"' package.json > tmp.json
          mv tmp.json package.json

      - name: Commit version bump
        run: |
          git add package.json
          git commit -m "chore: bump version to ${{ steps.new.outputs.version }}"
          git push

      - name: Create and push tag
        run: |
          git tag "v${{ steps.new.outputs.version }}"
          git push origin "v${{ steps.new.outputs.version }}"

      - name: Generate release notes
        id: notes
        run: |
          last_tag=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          new_version="${{ steps.new.outputs.version }}"

          if [ -z "$last_tag" ]; then
            commits=$(git log --pretty=format:"%h|%s" --no-merges)
          else
            commits=$(git log --pretty=format:"%h|%s" --no-merges "$last_tag"..HEAD^)
          fi

          repo="elitan/frost"

          breaking=""
          features=""
          fixes=""
          docs=""
          refactor=""
          perf=""

          # Parse commit: strip type prefix, capitalize, add links
          parse_commit() {
            local hash="$1"
            local msg="$2"

            # Strip type/scope prefix
            local text=$(echo "$msg" | sed -E 's/^[a-z]+(\([^)]+\))?!?: //')
            # Capitalize first letter
            text="$(echo "${text:0:1}" | tr '[:lower:]' '[:upper:]')${text:1}"

            # Convert PR references (#123) to links
            text=$(echo "$text" | sed -E "s/#([0-9]+)/[#\1](https:\/\/github.com\/$repo\/pull\/\1)/g")

            # Add commit link
            echo "$text ([\`$hash\`](https://github.com/$repo/commit/$hash))"
          }

          while IFS='|' read -r hash msg; do
            [ -z "$msg" ] && continue
            [[ "$msg" =~ ^chore: ]] && continue

            parsed=$(parse_commit "$hash" "$msg")

            if [[ "$msg" =~ !: ]] || [[ "$msg" =~ BREAKING ]]; then
              breaking="$breaking\n- $parsed"
            elif [[ "$msg" =~ ^feat ]]; then
              features="$features\n- $parsed"
            elif [[ "$msg" =~ ^fix ]]; then
              fixes="$fixes\n- $parsed"
            elif [[ "$msg" =~ ^docs ]]; then
              docs="$docs\n- $parsed"
            elif [[ "$msg" =~ ^refactor ]]; then
              refactor="$refactor\n- $parsed"
            elif [[ "$msg" =~ ^perf ]]; then
              perf="$perf\n- $parsed"
            fi
          done <<< "$commits"

          notes=""

          # Migration warning at top
          if [ -n "$last_tag" ]; then
            schema_changes=$(git diff --name-only "$last_tag" HEAD -- schema/ | wc -l)
            if [ "$schema_changes" -gt 0 ]; then
              notes="> **This release includes database migrations.** Back up your data before updating.\n\n"
            fi
          fi

          [ -n "$breaking" ] && notes="$notes### Breaking Changes\n$breaking\n\n"
          [ -n "$features" ] && notes="$notes### Features\n$features\n\n"
          [ -n "$fixes" ] && notes="$notes### Fixes\n$fixes\n\n"
          [ -n "$perf" ] && notes="$notes### Performance\n$perf\n\n"
          [ -n "$refactor" ] && notes="$notes### Refactoring\n$refactor\n\n"
          [ -n "$docs" ] && notes="$notes### Documentation\n$docs\n\n"

          # Changelog link
          if [ -n "$last_tag" ]; then
            notes="$notes---\n**Full changelog:** [$last_tag â†’ v$new_version](https://github.com/elitan/frost/compare/$last_tag...v$new_version)"
          fi

          echo -e "$notes" > release_notes.md

      - name: Create release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "v${{ steps.new.outputs.version }}" \
            --title "v${{ steps.new.outputs.version }}" \
            --notes-file release_notes.md
